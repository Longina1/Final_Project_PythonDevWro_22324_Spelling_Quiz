
 



Python DevWro 2023-2024

Projekt końcowy

Aplikacja „Mistrz ortografii”























Spis treści






























1.	Cel
Celem projektu jest stworzenie aplikacji z graficznym interfejsem użytkownika z wykorzystaniem biblioteki tkinter. Aplikacja daje użytkownikowi możliwość sprawdzenia wiedzy ortograficznej i jest dostępna w dwóch wersjach: pierwsza to test wyboru (z zastosowaniem widżetu checkbox), a druga pozwala użytkownikowi wpisać znaki (w oparciu o widżet tekstowy).
Do stworzenia aplikacji zostały wykorzystane następujące bloki konstrukcyjne:
- kontenery: frame, buttonframe,
- przyciski: button, checkbutton,
- widżety tekstowe: label, text.

Wersja 1
Test wyboru

1. Pierwszym etapem jest zaimportowanie modułu tkinter jako tk oraz stworzenie aplikacji.

import tkinter as tk
root = tk.Tk()


2. Kolejnym krokiem jest określenie wielkości i geometrii okna (umieszczenie okna w centralnym punkcie ekranu po uprzednim pobraniu wielkości ekranu).

window_width = 800
window_height = 600

screen_width = root.winfo_screenwidth()
screen_height = root.winfo_screenheight()
centre_x = int(screen_width/2 - window_width / 2)
centre_y = int(screen_height/2 - window_height / 2)
root.geometry(f'{window_width}x{window_height}+{centre_x}+{centre_y}')

Dodatkowo, stworzona jest możliwość zmiany rozmiarów okna (zarówno szerokości, jak i wysokości), a samo okno będzie wyświetlane „zawsze na wierzchu”. Okno ma również nadany tytuł i skonfigurowany kolor tła oraz dodaną ikonę.

3. Na potrzeby aplikacji utworzona jest również ramka.

frame = tk.Frame()
frame.pack()


4. Test zawiera dziesięć zdań zapakowanych w listę questions – każde zdanie to element listy. Wybrane litery w zdaniach zostały zastąpione znakiem podkreślenia, a zadaniem użytkownika jest podanie litery, której brakuje w pustych miejscach.

questions = ['1. St_ł bez n_g chowam za r_g.',
    '2. _urawie _erują w trawie.',
    '3. _ółta _aba szuka kraba.',
    '4. Czy _arty mają duży hart du_a?',
    '5. Mu_a nie wypełni brzu_a żuka.',
    '6. R_żowa k_zka weszła do w_zka.',
    '7. Ły_ka i ły_eczka, a do tego fili_aneczka.',
    '8. Kto bazg_e po mu_e zamiast wycierać ku_e?',
    '9. Ka_dy mo_e jechać nad morze.',
    '10. Na d_ewie mieszka zwie_ę.'
]


Użytkownik będzie miał do wyboru jedną z dwóch podanych opcji. Do każdego z wyświetlanych zdań zdefiniowana jest lista dwóch opcji. Podobnie jak zdania, opcje zapakowane są w listę (tym razem elementami listy są listy zawierające po dwie opcje).

options = [['u', 'ó'],
            ['ż', 'rz'],
            ['rz', 'ż'],
            ['h', 'ch'],
            ['ch', 'h'],
            ['ó', 'u'],
            ['ż', 'rz'],
            ['rz', 'ż'],
            ['ż', 'rz'],
            ['rz', 'ż']
]


Ostatnią listę stanowią odpowiedzi. Odpowiedzią może być cyfra całkowita 1 (pierwszy checkbox) lub 2 (drugi checkbox).



answers = [2, 1, 2, 2, 1, 1, 1, 1, 1, 1]
W celu obliczenia wyniku testu definiowane są zmienne score (mająca początkowo wartość 0 i zwiększana w przypadku podania prawidłowej odpowiedzi) i total_no_of_questions (odpowiadająca liczbie pytań, będąca jednocześnie informacją o zakończeniu testu i możliwości wyświetlenia wyniku). Dodatkowo, definiowana jest zmienna question_no, wskazująca aktualnie wyświetlane pytanie (początkowo wskazująca pytanie nr 1).

score = 0
total_no_of_questions = 10
question_no = 1


4. Widżety
Na potrzeby aplikacji tworzone są widżety. Pierwsza etykieta (instruction) zawiera krótką instrukcję dla użytkownika (jest to tekst, dla którego określona jest czcionka i kolor tła). Kolejna etykieta (space) oddziela instrukcję od pytania zasadniczego (question), dla którego zdefiniowana jest również czcionka i kolor tła. Etykieta wypełnia przypisaną jej przestrzeń horyzontalnie (opcja pack(fill=’x’) i jest umieszczona w aplikacji przy pomocy metody pack(). Pierwsze pytanie znajduje się w liście questions i ma indeks 0


instruction = tk.Label(frame, text='Wpisz literę, której brakuje w poniższym zdaniu.', font=('Arial', 10), bg='#FAFAFA')
instruction.pack(fill='x', expand=True)

space = tk.Label(frame, text=' \n  \n ', bg='#FAFAFA')
space.pack(fill='x', expand=True)

question = tk.Label(root, text=questions[0], font=('Arial', 25), bg='#E0F7FA')
question.pack(fill='x')

Przed stworzeniem kolejnych widżetów (przycisków) definiowane są dwie zmienne klasy IntVar, aby przechowywać informację o opcji wybranej przez użytkownika (opcja 1 lub opcja 2).

value1 = tk.IntVar()
value2 = tk.IntVar()

Z uwagi na fakt, że użytkownik będzie miał do wyboru dwie opcje, tworzone są dwa przyciski checkbutton. Dla każdego z nich podana jest zmienna variable (wcześniej zdefiniowana zmienna value1 dla option1 i value2 dla option2) oraz funkcja lambda {pkt 5} odwołująca się do funkcji check z argumentem 1 dla option1 (jeśli użytkownik wybierze pierwszą opcję) i argumentem 2 dla option2 (jeśli użytkownik wybierze drugą opcję). Jeżeli użytkownik wybierze opcję pierwszą (option1, czyli pierwszy checkbox), przekazana będzie wartość 1 , a jeśli użytkownik wybierze drugą opcję, przekazana będzie wartość 2. >> teraz funkcja check
Wyświetlanym tekstem będzie zawartość listy options. Z uwagi na fakt, że jest to tablica dwuwymiarowa, najpierw należy podać indeks pierwszej listy (tj. pierwszego elementu listy options) i pierwszej opcji (w option1: [0][0]) oraz indeks tego samego elementu i drugiej opcji (w option2: [0][1])


option1 = tk.Checkbutton(root, variable=value1, text=options[0][0], font=('Arial', 20), bg='#FAFAFA', command=lambda: check(1))
option1.pack()

option2 = tk.Checkbutton(root, variable=value2, text=options[0][1], font=('Arial', 20), bg='#FAFAFA', command=lambda: check(2))
option2.pack()


Następnie tworzony jest przycisk next_btn, zawierający tekst, zdefiniowane tło oraz polecenie przejścia do kolejnego okna zdefiniowane w osobnej funkcji (next). / odwołanie do funkcji next().

next_btn = tk.Button(root, text='Dalej', bg='#BBDEFB', command=next)
next_btn.pack()

5. Funckja check
Aby zablokować możliwość zaznaczenia wszystkich opcji jednocześnie (prawidłowa jest tylko jedna z dwóch podanych opcji), tworzona jest funkcja check().

def check(option):
    if option == 1:
        value2.set(0)
    else:
        value1.set(0)

Jeśli opcja wynosi 1, wówczas druga opcja powinna mieć wartość 0. W tym celu zastosowana została metoda set(), nadająca drugiej zmiennej (value2) wartość 0 w przypadku wybrania pierwszej opcji i wartość 0 pierwszej zmiennej (value1), jeśli wybrana zostanie druga opcja. Nadanie wartości 0 niewybranemu polu checkbox sprawia, że pole to będzie odznaczone.

6. Funkcja next()
Do funkcji importowane są zmienne globalne: score i question_no (zmienne utworzone poza funkcją next()).

Funkcja next() pozwala na przejście do kolejnego pytania. Aby wyświetlenie okna z kolejnym pytaniem było możliwe, konieczne jest ustalenie, którą z dwóch opcji wybrał użytkownik. W tym celu określana jest zmienna selected_option. Jeśli użytkownik wybrał opcję pierwszą (co jest mapowane na zmienną value1 / value2 z wykorzystaniem metody get()), zmienna selected_option przybierze wartość 1, a jeśli wybrana została druga opcja, zmienna selected_option będzie równa 2. Jeśli użytkownik nie wybierze żadnej z dwóch opcji i przejdzie do kolejnego pytania klikając przycisk Dalej, przyjmowane jest założenie, że selected_option wynosi 0 (-1).
Następnie można porównać wybraną opcję (zmienną selected_option) z prawidłową odpowiedzią na dane pytanie (od zmiennej question_no odejmowana jest liczba 1, aby uwzględnić lokalizację elementów listy zaczynającą się od indeksu 0). Jeśli obie zmienne są takie same, wynik (score) zostanie powiększony o wartość 1.
Na tym etapie aktualizowana jest również zmienna question_no.
Kiedy użytkownik odpowie na ostatnie pytanie, wyświetlony zostanie wynik. W tym celu porównywany jest numer bieżącego pytania (question_no) z całkowitą liczbą wszystkich pytań (total_no_of_questions) //total_ jest zmienna globalną, ale nie jest aktualizowana w funkcji, więc nie trzeba jej importować// Przycisk Dalej pozwalający na przejście do kolejnego pytania nie jest potrzebny po udzieleniu odpowiedzi na wszystkie pytania, dlatego też zostanie ukryty przez wywołania funkcji pack_forget(). Na potrzeby wyświetlenia wyniku definiowana jest etykieta score_label, zawierająca tekst informujący o wyniku wraz z wartością liczbową wyniku oraz opcje czcionki i tła. Widżet z wynikiem będzie umieszczony w oknie z zachowaniem (poziomo i pinowo) 20 pikseli dookoła (na zewnątrz) jako padding.
Dodatkowo utworzony został przycisk umożliwiający zamknięcie okna (quit_button), zawierający tekst, tło i komendę quit, z uwzględnieniem marginesu wewnętrznego.
Jeżeli jednak bieżące pytanie nie jest ostatnim, wyświetlane będą kolejne pytania, co zostało określone w dalszej części funkcji warunkowej. W części else modyfikowana (zwiększana) będzie lokalizacja kolejnego pytania i opcji dla każdej etykiety-pytania i przycisku checkbutton. Aby zaktualizować pytanie, zastosowana została metoda config(), a jako tekst wyświetlone pytanie z listy (uwzględniając indeksowanie od 0, stąd question_no – 1). Podobnie zaktualizowane zostały dwie dostępne opcje.
Zanim jednak wyświetlone będzie kolejne pytanie, resetowane są opcje, aby opcja wybrana dla poprzedniego pytania nie wyświetlała się jako zaznaczona dla kolejnego pytania. Resetowanie opcji pozwala na wyświetlenie pytania wraz z dwoma niezaznaczonymi opcjami, pozwalając użytkownikowi na wybranie jednej z nich, bez kopiowania wcześniejszego wyboru. Wobec tego zanim program przejdzie do wyświetlania kolejnego pytania wartość zmiennej value1 i value2 zostanie ustawiona jako 0 z wykorzystaniem metody set().

def next():
    global score,question_no
    if value1.get() == 1:
        selected_option = 1
    elif value2.get() == 1:
        selected_option = 2
    else:
        selected_option = -1

    if answers[question_no - 1] == selected_option:
        score += 1

    question_no += 1

    if question_no > total_no_of_questions:
        next_btn.pack_forget()
        score_label = tk.Label(root, text='Twój wynik: '+ str(score), font=('Arial', 30), bg='#FFFAFA', fg='#2F4F4F')
        score_label.pack(padx=20, pady=20)
        quit_button = tk.Button(root, text='Koniec', command=root.quit, bg='#FFE4E1')
        quit_button.pack(ipadx=5, ipady=15, expand=True)

    else:
        value1.set(0)
        value2.set(0)
        question.config(text=questions[question_no - 1])
        option1.config(text=options[question_no - 1][0])
        option2.config(text=options[question_no - 1][1])


Ostatnim krokiem jest uruchomienie aplikacji.
root.mainloop()


Wersja 2
Pole tekstowe
Druga wersja aplikacji powstała przy podobnych założeniach. Różnica między obydwoma wersjami polega na tym, że przycisk checkbutton został zastąpiony polem tekstowym, w którym użytkownik wpisuje odpowiedź. W tym celu umożliwienia użytkownikowi wprowadzenia napisu  zdefiniowany został widżet entry. Ponadto, w linii zdefiniowana została zmienna entry_text z wykorzystaniem StringVar(), której zadaniem jest przechowywanie wartości napisu.

entry = tk.Entry(frame, textvariable=entry_text)
entry.pack()

entry_text = tk.StringVar()

Podobnie jak w przypadku testu wyboru konieczne było zapewnienie, aby wprowadzona odpowiedź na dane pytanie nie została przeniesiona do kolejnego okna. W celu wyczyszczenia pola tekstowego użyta została metoda delete() z punktem startowym 0. (text: 1.0, entry2: 0)
